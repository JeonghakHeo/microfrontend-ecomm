npm start webpack:
bundle and output

npm start webpack serve:
run dev server, must be with devServer in webpack.config

HtmlWebpackPlugin:
place output bundle to html(in path defined in template)

** Module Federation **

// products
new ModuleFederationPlugin({
  name: 'products',
  filename: 'remoteEntry.js',
  exposes: {
    './ProductsIndex': './src/index',
  },
})

// container
new ModuleFederationPlugin({
  name: 'container',
  remotes: {
    products: 'products@http://localhost:8081/remoteEntry.js',
  },
}),

// container bootstrap.js
import 'products/ProductsIndex'
// container index.js
import('./bootstrap')

** Section3 **

L.20-21 Sharing dupe module
shared: ['faker'] in product, cart
new ModuleFederationPlugin({
  name: '',
  filename: 'remoteEntry.js',
  exposes: {
    '': './src/index',
  },
  shared: ['faker']
})

Error: Shared module is not available for eager consumption
A module marked as shared, it is by default loaded asynchronously.
So when entry file, index.js, gets loaded, it tries to use faker module instantaneously but we haven't loaded

To fix, add import() to give Webpack the opportunity to take a look at what files the codes require to run successfully. When this opportunity given, Webpack can go load up the module before we try to execute the codes

// index.js
import('./bootstrap')
// products.js
import faker from 'faker'

L.22
if shared modules have different major version, Webpack will load each of them, not as one single shared module.

// ^major.minor.patch
^4.1.1 ^4.2.3 can be loaded as shared
^5.1.0 ^4.1.1 cannot be loade as shared

L.24 Sub-App Execution Context
In sub apps, they have thier own html to accept/display the output bundle.
But in main app on produciton, it has a different html file that has different elements than the elements that have been used in isolated apps. 
The main point to implement microfrontend is each engineering team can develop their products in isolation, so they should be able to develop and test on their isolated app.

// A big assumption 
document.querySelector('#dev-products').innerHTML = products
We assume there will be an element with id of #dev-products.
But it might not exist in production html.